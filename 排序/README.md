# 简单排序
主要操作：比较两个数据项、交换两个数据项或复制其中一项，具体操作要看排序的类型。
### 1.冒泡排序
运行效率较低, 但是在概念上它是排序算法中最简单的，最适合初学的一种排序，具体思路为：
- 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
- 如果左边的队员高, 则两队员交换位置
- 向右移动一个位置, 比较下面两个队员
- 当走到最右端时, 最高的队员一定被放在了最右边
- 继续从最左边开始排序，把第二高的队员排到倒数第二位置上
- 依此类推，完成排序

```javascript
ArrayList.prototype.bubbleSort = function () {
    // 1.获取数组的长度
    var length = this.array.length

    // 2.反向循环, 因此次数越来越少
    for (var i = length - 1; i >= 0; i--) {
        // 3.根据i的次数, 比较循环到i位置
        for (var j = 0; j < i; j++) {
            // 4.如果j位置比j+1位置的数据大, 那么就交换
            if (this.array[j] > this.array[j+1]) {
                // 交换
                this.swap(j, j+1)
            }
        }
    }
}

ArrayList.prototype.swap = function (m, n) {
    var temp = this.array[m]
    this.array[m] = this.array[n]
    this.array[n] = temp
}
```
冒泡排序的效率为O(N²)，比较次数为N²，交换次数也为N²
### 2.选择排序
思路：
- 选定第一个索引位置，然后和后面元素依次比较
- 如果后面的队员, 小于第一个索引位置的队员, 则交换位置
- 经过一轮的比较后, 可以确定第一个位置是最小的
- 然后使用同样的方法把剩下的元素逐个比较即可
- 可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后

```javascript
ArrayList.prototype.selectionSort = function () {
    // 1.获取数组的长度
    var length = this.array.length

    // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
    for (var i = 0; i < length - 1; i++) {
        // 3.内层循环: 从i+1位置开始, 和后面的内容比较
        var min = i
        for (var j = min + 1; j < length; j++) {
            // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置
            if (this.array[min] > this.array[j]) {
                min = j
            }
        }
        // 5.交换min和i位置的数据
        this.swap(min, i)
    }
}
```
选择排序虽然效率也是O(N²)，但在一定程度上优化了冒泡排序的效率，比较次数跟选择排序的效率一样都是O(N²)，交换次数是O(N)。
### 3.插入排序
> 插入排序是简单排序中效率最好的一种，也是学习其他高级排序的基础, 比如希尔排序/快速排序, 所以也非常重要。

思路：
- 从第一个元素开始，该元素可以认为已经被排序
- 取出下一个元素，在已经排序的元素序列中从后向前扫描
- 如果该元素（已排序）大于新元素，将该元素移到下一位置
- 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置
- 将新元素插入到该位置后, 重复上面的步骤

# 高级排序
